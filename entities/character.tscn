[gd_scene load_steps=11 format=3 uid="uid://bfvl2terb63tc"]

[ext_resource type="Texture2D" uid="uid://dulns1vrtabso" path="res://assets/player.png" id="2_tgnx7"]
[ext_resource type="PackedScene" uid="uid://cobvkoy8n5f5w" path="res://weapons/gun.tscn" id="3_ms75q"]
[ext_resource type="PackedScene" uid="uid://cjtek7s4wju4r" path="res://team.tscn" id="4_bkhtu"]

[sub_resource type="GDScript" id="GDScript_krwtj"]
script/source = "extends CharacterBody2D

class_name Character

signal died
signal commenced_attack
signal got_hit

var state := CharacterState.IDLE:
	set(new_state):
		if new_state == state:
			return
		state = new_state
	get:
		return state

func set_state(p_state):
	state = p_state
	
func get_state():
	return state

@onready var nav_agent: NavigationAgent2D = $NavigationAgent2D

@onready var detection_zone = $DetectionZone
@onready var fov			= $DetectionZone/FOV
@onready var end_of_fov		= $DetectionZone/EndOfFOV

@onready var weapon   		= $Weapon
@onready var barrel     	= $Weapon/GunBarrel
@onready var weapon_sprite 	= $Weapon/GunSprite

@onready var animations = $AnimationPlayer
@onready var sprite 	= $CharacterSprite

@onready var team			= $Team
@onready var shoot_cooldown = $Cooldown

var targets_queue := Array()
var potential_targets := Array()
var potential_target_idx: int = 0

var target = null
var target_pos: Vector2
var target_distance = -1

@export var health: int = 100
@export var speed: int = 300
@export var rotation_speed = PI * 1.1

func _ready():
	pass

func get_team():
	return team.team

func set_target(new_target):
	target = new_target
	
func get_target():
	return target

func _physics_process(_delta):
	if !potential_targets.is_empty():
		track_potential_target(potential_targets[potential_target_idx])
		if !potential_targets.is_empty():
			potential_target_idx += 1
			potential_target_idx %= potential_targets.size()
	
	track_target()
	
	nav_agent.set_velocity(velocity)
	animate()

func animate():
	if velocity == Vector2.ZERO:
		animations.play(\"idle\")
	else: 
		animations.play(\"run\")
	
	if barrel.global_position.x - self.global_position.x < 0:
		weapon_sprite.flip_v = true
		weapon_sprite.offset = Vector2(0, -2)
		sprite.flip_h = true
	else:
		weapon_sprite.flip_v = false
		weapon_sprite.offset = Vector2(0, 2)
		sprite.flip_h = false

func _on_detection_zone_body_entered(body):
	if (
			!body.has_method(\"get_team\")  
			or body.get_team() == team.team
	):
		return
	
	potential_targets.push_front(body)

func _on_detection_zone_body_exited(body):
	if (
			body.has_method(\"get_team\") == false
			or body.get_team() == team.team
	):
		return
	
	var idx = potential_targets.find(body)
	
	if idx != -1:
		potential_targets.pop_at(idx)
	elif target != body:
		idx = targets_queue.find(body)
		if idx == -1:
			print(\"Error this shouldn't happen for the enemy\")
			return 
		targets_queue.pop_at(idx)
	
	if target and target == body:
		if targets_queue.size() <= 1:
			targets_queue.pop_front()
			target = null
		else:
			targets_queue.pop_front()
			target = targets_queue[0]

func track_potential_target(body):
	if body == null:
		return
	
	var ray = create_ray(global_position, body.global_position)
	
	if (ray[\"collider\"] != body):
		return
	
	potential_targets.pop_at(potential_targets.find(body))
	targets_queue.append(body)
	
	if target == null:
		target = targets_queue[0]
		target = target
		_on_nav_update_timeout()
	
	commenced_attack.emit()

func track_target():
	if target == null:
		return
		
	var ray = create_ray(global_position, target.global_position)
	
	if (ray[\"collider\"] != target):
		if targets_queue.size() <= 1:
			targets_queue.pop_front()
			potential_targets.push_front(target)
			_on_nav_update_timeout()
			target = null
		else:
			targets_queue.pop_front()
			potential_targets.push_front(target)
			target = targets_queue[0]
			_on_nav_update_timeout()


func turn_to(target, p_rotation_speed = PI):
	match typeof(target):
		TYPE_FLOAT:
			turn_to_angle(target, p_rotation_speed)
		TYPE_VECTOR2:
			var turn_angle = weapon.global_position.direction_to(target).angle()
			turn_to_angle(turn_angle, p_rotation_speed)
		_:
			return 

func turn_to_angle(p_angle: float, p_rotation_speed = PI):
	var angle = lerp_angle(weapon.rotation, p_angle, 1)
	var direction = clamp(angle, weapon.rotation - p_rotation_speed, weapon.rotation + p_rotation_speed)
	weapon.rotation = direction
	detection_zone.rotation = weapon.rotation + PI/2

func take_damage(damage):
	health -= damage
	if health <= 0:
		died.emit(self)
		queue_free()

func get_move_direction() -> Vector2:
	return global_position.direction_to(nav_agent.get_next_path_position())
	
func get_next_pos() -> Vector2:
	return nav_agent.get_next_path_position()

func _on_nav_update_timeout():
	if target != null:
		nav_agent.target_position = target.global_position

func set_nav_agent_target_pos(p_pos):
	nav_agent.target_position = p_pos

func _on_navigation_agent_2d_velocity_computed(safe_velocity):
	clamp(velocity, Vector2.ZERO, safe_velocity)

func create_ray(from: Vector2, to: Vector2) -> Dictionary:
	var space_state = get_world_2d().direct_space_state
	var query = PhysicsRayQueryParameters2D.create(from, to, collision_mask ^ collision_layer, [self])
	return space_state.intersect_ray(query)

func get_hit_from(p_hit_from: Vector2):
	if state == CharacterState.ATTACK or state == CharacterState.PLAYER:
		return
	
	var move_distance = global_position.distance_to(end_of_fov.global_position)
	target_pos = global_position + move_distance * p_hit_from.normalized()
	var ray: Dictionary = create_ray(global_position, target_pos)
	
	if !ray.is_empty():
		target_pos = ray[\"position\"]
	
	set_nav_agent_target_pos(target_pos)
	
	got_hit.emit()
"

[sub_resource type="CapsuleShape2D" id="CapsuleShape2D_f15xe"]
radius = 13.0
height = 46.0

[sub_resource type="Animation" id="Animation_od7ud"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("CharacterSprite:region_enabled")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [true]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("CharacterSprite:hframes")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [1]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("CharacterSprite:vframes")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [1]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("CharacterSprite:frame")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [0]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("CharacterSprite:region_rect")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Rect2(33, 35, 26, 44)]
}

[sub_resource type="Animation" id="Animation_622tn"]
resource_name = "idle"
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("CharacterSprite:region_enabled")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [true]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("CharacterSprite:hframes")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [1]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("CharacterSprite:vframes")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [1]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("CharacterSprite:frame")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [0]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("CharacterSprite:region_rect")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Rect2(33, 35, 26, 44)]
}

[sub_resource type="Animation" id="Animation_uo48r"]
resource_name = "run"
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("CharacterSprite:hframes")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [4]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("CharacterSprite:vframes")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [1]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("CharacterSprite:region_enabled")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [true]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("CharacterSprite:region_rect")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Rect2(0, 317, 384, 52)]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("CharacterSprite:frame")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0, 0.3, 0.6, 0.9),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 1,
"values": [0, 1, 2, 3]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_1m63o"]
_data = {
"RESET": SubResource("Animation_od7ud"),
"idle": SubResource("Animation_622tn"),
"run": SubResource("Animation_uo48r")
}

[sub_resource type="CapsuleShape2D" id="CapsuleShape2D_1og35"]
radius = 56.5574
height = 231.897

[node name="Character" type="CharacterBody2D"]
position = Vector2(564, -3)
collision_layer = 2
collision_mask = 135
motion_mode = 1
slide_on_ceiling = false
wall_min_slide_angle = 0.0
safe_margin = 2.0
script = SubResource("GDScript_krwtj")

[node name="CharacterSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_tgnx7")
region_enabled = true
region_rect = Rect2(33, 35, 26, 44)

[node name="Collision" type="CollisionShape2D" parent="."]
position = Vector2(0, -1)
shape = SubResource("CapsuleShape2D_f15xe")

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
"": SubResource("AnimationLibrary_1m63o")
}
autoplay = "idle"

[node name="Weapon" parent="." instance=ExtResource("3_ms75q")]

[node name="DetectionZone" type="Area2D" parent="." groups=["Enemy"]]
scale = Vector2(2.44, 2.32)
collision_layer = 7
collision_mask = 7

[node name="FOV" type="CollisionShape2D" parent="DetectionZone"]
position = Vector2(1.22951, -115.086)
shape = SubResource("CapsuleShape2D_1og35")

[node name="EndOfFOV" type="Marker2D" parent="DetectionZone"]
position = Vector2(-1.63934, -230.172)

[node name="Team" parent="." instance=ExtResource("4_bkhtu")]
team = 1

[node name="Cooldown" type="Timer" parent="."]
wait_time = 0.5
one_shot = true

[node name="NavigationAgent2D" type="NavigationAgent2D" parent="."]
path_desired_distance = 30.0
target_desired_distance = 100.0
path_max_distance = 200.0
navigation_layers = 129
avoidance_enabled = true
radius = 50.0
neighbor_distance = 200.0
max_neighbors = 4
max_speed = 1000.0
debug_enabled = true
debug_path_custom_color = Color(1, 0, 1, 1)

[node name="NavUpdate" type="Timer" parent="."]
wait_time = 0.3
autostart = true

[connection signal="body_entered" from="DetectionZone" to="." method="_on_detection_zone_body_entered"]
[connection signal="body_exited" from="DetectionZone" to="." method="_on_detection_zone_body_exited"]
[connection signal="velocity_computed" from="NavigationAgent2D" to="." method="_on_navigation_agent_2d_velocity_computed"]
[connection signal="timeout" from="NavUpdate" to="." method="_on_nav_update_timeout"]
